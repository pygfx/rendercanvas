<!doctype html>
<html>
<head>
    How to distinguish multiple canvas elements?:<br>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.28.2/full/pyodide.js"></script>
</head>
<body>
<!-- declare your canvas elements with a unique id tag -->
<canvas id="redCanvas" width="320" height="240" style="background-color: red;"></canvas>
<canvas id="greenCanvas" width="320" height="240" style="background-color: green;"></canvas>
<canvas id="blueCanvas" width="320" height="240" style="background-color: blue;"></canvas>
<br>
First canvas updates when the pointer hovers, second canvas changes direction while keypress, third canvas updates when you click!

<script type="text/javascript">
    async function main(){
        pythonCode = `
        from rendercanvas.auto import RenderCanvas, loop
        import numpy as np

        # use the canvas_el argument to select the canvas by its id tag
        canvas_red = RenderCanvas(canvas_el="#redCanvas", size=(320, 240), update_mode="ondemand")
        canvas_blue = RenderCanvas(canvas_el="#blueCanvas", size=(320, 240), update_mode="ondemand")

        # or have the element via your own code
        from js import document
        green_canvas_el = document.getElementById("greenCanvas")
        canvas_green = RenderCanvas(canvas_el=green_canvas_el, size=(320, 240), update_mode="continuous")

        context_red = canvas_red.get_context("bitmap")
        context_green = canvas_green.get_context("bitmap")
        context_blue = canvas_blue.get_context("bitmap")

        red_data = np.random.uniform(127, 255, size=(24, 32, 4)).astype(np.uint8)
        red_data[..., 0] = 255
        
        green_data = np.random.uniform(0, 255, size=(24, 32, 4)).astype(np.uint8)
        green_data[..., 1] = 255
        green_data[..., 3] = 255 # solid alpha for this one
        
        blue_data = np.random.uniform(127, 255, size=(24, 32, 4)).astype(np.uint8)
        blue_data[..., 2] = 255

        @canvas_red.add_event_handler("pointer_enter")
        def on_pointer_enter_red(event):
            canvas_red.set_update_mode("continuous")

        @canvas_red.add_event_handler("pointer_leave")
        def on_pointer_leave_red(event):
            canvas_red.set_update_mode("ondemand")

        @canvas_green.add_event_handler("key_down")
        def on_key_down_green(event):
            green_data[0, 0, 3] = 254 # storing my bit flag in the data

        @canvas_green.add_event_handler("key_up")
        def on_key_up_green(event):
            green_data[0, 0, 3] = 255

        @canvas_blue.add_event_handler("pointer_down")
        def on_pointer_click_blue(event):
            pos = (int(event["y"]//10), int(event["x"]//10))
            blue_data[pos[0]-1:pos[0]+2, pos[1]-1:pos[1]+2, 0:2] += 128
            canvas_blue.request_draw() # trigger the draw with the click event too!

        @canvas_red.request_draw
        def animate_red():
            red_data[..., 1] += 10
            red_data[..., 2] += 19
            context_red.set_bitmap(red_data)

        @canvas_green.request_draw
        def animate_green():
            if green_data[0, 0, 3] < 255:
                # move downwards
                green_data[1:, :, [0,2]] = green_data[:-1, :, [0,2]]
                green_data[0, :, [0,2]] = green_data[-1, :, [0,2]]
            else:
                # move upwards
                green_data[:-1, :, [0,2]] = green_data[1:, :, [0,2]]
                green_data[-1, :, [0,2]] = green_data[0, :, [0,2]]
            context_green.set_bitmap(green_data)
            
        def animate_blue():
            context_blue.set_bitmap(blue_data)

        canvas_blue.request_draw(animate_blue)

        loop.run()
        `
        // Load Pyodide
        let pyodide = await loadPyodide();

        await pyodide.loadPackage("micropip");
        const micropip = pyodide.pyimport("micropip");
        await micropip.install('numpy');
        // await micropip.install('rendercanvas');
        await micropip.install('../dist/rendercanvas-2.2.1-py3-none-any.whl'); // local wheel for auto testing

        // Run the Python code async because some calls are async it seems.
        pyodide.runPythonAsync(pythonCode);
    }
    main();
</script>
</body>
</html>